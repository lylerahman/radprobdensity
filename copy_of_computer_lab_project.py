# -*- coding: utf-8 -*-
"""Copy of Computer lab project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gCFZFJk2M3F1dxMiEuXOOUa8bdyCE4Gi

# Computing Probability Density with a Graphical Representation

# Part 1. Computing Probability Density from the Wave Function

Import relevant modules
"""

#import modules for numerical calculations and graphing capabilities.
import matplotlib, matplotlib.pyplot as plt
import numpy as np
import sys

"""Create first 6 Radial Wave Functions for the Hydrogen Atom"""

# Define the Bohr radius
a_0 = 5.29e-11

#Radial Wave Function for 1_0, the 1s orbital.
def radial_wave_function_1_0(r):
    return 2 * (a_0**(-3/2)) * np.exp(-r/a_0)

#Radial Wave Function for 2_0, the 2s orbital.
def radial_wave_function_2_0(r):
    return (1/np.sqrt(2)) * (a_0**(-3/2)) * (1 - (r/(2*a_0))) * np.exp(-r/(2*a_0))

#Radial Wave Function for 2_1, the 2p orbitals.
def radial_wave_function_2_1(r):
    return (1/np.sqrt(24)) * (a_0**(-3/2)) * (r/a_0) * np.exp(-r/(2*a_0))

#Radial Wave Function for 3_0, the 3s orbital.
def radial_wave_function_3_0(r):
    return (2/np.sqrt(27)) * (a_0**(-3/2)) * (1 - (2*r/(3*a_0)) + (2*r**2/(27*a_0**2))) * np.exp(-r/(3*a_0))

#Radial Wave Function for 3_1, the 3p orbitals.
def radial_wave_function_3_1(r):
    return (8/(27 * np.sqrt(6))) * (a_0**(-3/2)) * (1 - (r/(6*a_0))) * (r/a_0) * np.exp(-r/(3*a_0))

#Radial Wave Function for 3_2, the 3d orbitals.
def radial_wave_function_3_2(r):
    return (4/(81 * np.sqrt(30))) * (a_0**(-3/2)) * (r**2/a_0**2) * np.exp(-r/(3*a_0))

# Ask the user to input a number
state = input("Enter the desired state, for example: 1s orbital = 1_0, s=0, p=1, d=2. State= ")

"""Create if/elif statements to assign a formula to the user input"""



#if user selects state, the radial function used will be equal to the corresponding radial wave function.
if state == "1_0":
    radial_function = radial_wave_function_1_0
elif state == "2_0":
    radial_function = radial_wave_function_2_0
elif state == "2_1":
    radial_function = radial_wave_function_2_1
elif state == "3_0":
    radial_function = radial_wave_function_3_0
elif state == "3_1":
    radial_function = radial_wave_function_3_1
elif state == "3_2":
    radial_function = radial_wave_function_3_2

# for other inputs, the program will produce an invalid response.
else:
    print("Invalid state. Please restart the program by: first, click 'Runtime' on the top menu. Second, click 'Restart session and run all', then proceed to enter a valid state. Example: 1s orbital = 1_0, format must be (quantum number_symbols) l=1, 2, 3. s=0, p=1, d=2.")
    sys.exit()

"""Create (2) plots based on the Radial Probability Density, calculated as the square of the Radial Wave Function assigned previously"""

# Create an array of values from 0 to 10 times the Bohr radius with 1000 points for a consistent curve.
r_values = np.linspace(0, 10*a_0, 1000)

# Customize the size of the graph.
plt.figure(figsize=(12, 4))

# Calculate the probability density (squared radial wave function)
probability_density = 4 * np.pi * r_values**2 * np.abs(radial_function(r_values))**2

# Plot the probability density (Line Graph)
# Use plt.subplot to specific the row/column for the first graph.
plt.subplot(1, 2, 1)
# Assign value sets for each graph axis.
plt.plot(r_values, probability_density)
# Label x and y axis and title.
plt.xlabel('Radial Distance (meters)')
plt.ylabel('Probability Density')
plt.title(f"Probability Density for State {state}")

# Plot the 2D colormap using imshow using the colormap 'viridus'.
# Use plt.subplot to specific the row/column for the first graph. Both will show side-by-side.
plt.subplot(1, 2, 2)
# Reshape probability density into a 2D array. Adjust aspect ratio to 'auto' for clarity. Set bounds for graph to 10 times the Bohr Radius.
plt.imshow(probability_density.reshape(1, -1), cmap='viridis', aspect='auto', extent=[0, 10*a_0, 0, 1])
# Create label for colorbar
plt.colorbar(label="Probability Density")
# Assign x and y axis and title.
plt.title(f"Probability Distribution for State {state}")
plt.xlabel("Radial Distance (meters)")
plt.ylabel("Probability Density")

# Use plt.tight_layout to fix overlapping labels on the graph.
plt.tight_layout()
plt.show()